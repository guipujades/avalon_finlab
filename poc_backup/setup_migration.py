"""
setup_migration.py - Script para configurar e migrar o sistema
"""

import os
import json
import shutil
from pathlib import Path
from datetime import datetime

def setup_folder_structure():
    """Cria estrutura de pastas necess√°ria"""
    folders = [
        "knowledge_base",
        "knowledge_base/novos_docs",
        "knowledge_base/docs_processados",
        "knowledge_base/documentos",
        "knowledge_base/documentos/resumos",
        "knowledge_base/documentos/extratos",
        "knowledge_base/documentos/relatorios",  # Compatibilidade
        "knowledge_base/indices",
        "logs",
        "cache"
    ]
    
    print("üìÅ Criando estrutura de pastas...")
    for folder in folders:
        Path(folder).mkdir(parents=True, exist_ok=True)
        print(f"   ‚úÖ {folder}")
    
    print("\n‚úÖ Estrutura de pastas criada com sucesso!")

def create_env_template():
    """Cria template do arquivo .env"""
    env_template = """# Configura√ß√µes do Sistema Multi-Agente

# OpenAI
OPENAI_API_KEY=your_openai_api_key_here

# Tavily (para busca web)
TAVILY_KEY=your_tavily_api_key_here

# LlamaParse (opcional - para processamento avan√ßado de PDFs)
LLAMA_CLOUD_API_KEY=your_llama_cloud_api_key_here

# Configura√ß√µes opcionais
LOG_LEVEL=INFO
CACHE_ENABLED=true
"""
    
    if not Path(".env").exists():
        with open(".env", "w") as f:
            f.write(env_template)
        print("üìù Arquivo .env criado - adicione suas API keys!")
    else:
        print("‚ö†Ô∏è  Arquivo .env j√° existe - verifique suas API keys")

def migrate_old_registry():
    """Migra registro antigo para novo formato"""
    old_registry_path = Path("document_registry.json")
    
    if not old_registry_path.exists():
        print("üìã Nenhum registro antigo encontrado - criando novo...")
        return create_new_registry()
    
    print("üîÑ Migrando registro antigo...")
    
    try:
        with open(old_registry_path, 'r', encoding='utf-8') as f:
            old_registry = json.load(f)
        
        # Cria backup
        backup_path = f"document_registry_backup_{datetime.now().strftime('%Y%m%d_%H%M%S')}.json"
        shutil.copy(old_registry_path, backup_path)
        print(f"   üì¶ Backup criado: {backup_path}")
        
        # Migra para novo formato
        new_registry = {
            "documents": {},
            "categories": {},
            "topics_index": {},
            "entities_index": {},
            "resumos": old_registry.get("resumos", {}),
            "last_scan": old_registry.get("last_scan"),
            "version": "2.0"
        }
        
        # Migra documentos
        for doc_id, doc_info in old_registry.get("documents", {}).items():
            # Detecta categoria
            categories = detect_categories(doc_info.get("name", ""), doc_info.get("summary_preview", ""))
            
            # Atualiza informa√ß√µes
            new_doc_info = doc_info.copy()
            new_doc_info["categories"] = categories
            new_doc_info["topics"] = []  # Ser√° preenchido no pr√≥ximo scan
            new_doc_info["entities"] = []  # Ser√° preenchido no pr√≥ximo scan
            
            new_registry["documents"][doc_id] = new_doc_info
            
            # Atualiza √≠ndice de categorias
            for cat in categories:
                if cat not in new_registry["categories"]:
                    new_registry["categories"][cat] = []
                new_registry["categories"][cat].append(doc_id)
        
        # Salva novo registro
        with open(old_registry_path, 'w', encoding='utf-8') as f:
            json.dump(new_registry, f, ensure_ascii=False, indent=2)
        
        print(f"   ‚úÖ Registro migrado: {len(new_registry['documents'])} documentos")
        print(f"   üìä Categorias: {list(new_registry['categories'].keys())}")
        
        return new_registry
        
    except Exception as e:
        print(f"   ‚ùå Erro na migra√ß√£o: {e}")
        print("   üí° Criando novo registro...")
        return create_new_registry()

def detect_categories(filename, content=""):
    """Detecta categorias baseado no nome e conte√∫do"""
    categories = []
    text = f"{filename} {content}".lower()
    
    category_keywords = {
        "financial_reports": ["earnings", "resultado", "balan√ßo", "financial"],
        "market_data": ["cota√ß√£o", "pre√ßo", "price", "ticker"],
        "research_analysis": ["an√°lise", "research", "recomenda√ß√£o"],
        "macroeconomic": ["macro", "economia", "infla√ß√£o", "pib"],
        "news_updates": ["not√≠cia", "news", "atualiza√ß√£o"],
        "educational": ["livro", "book", "curso", "tutorial"],
        "company_specific": ["empresa", "company", "corporate"],
        "sector_analysis": ["setor", "ind√∫stria", "sector"],
        "regulatory": ["regula√ß√£o", "regulatory", "compliance"]
    }
    
    for category, keywords in category_keywords.items():
        if any(keyword in text for keyword in keywords):
            categories.append(category)
    
    if not categories:
        categories.append("general")
    
    return categories

def create_new_registry():
    """Cria novo registro"""
    registry = {
        "documents": {},
        "categories": {},
        "topics_index": {},
        "entities_index": {},
        "resumos": {},
        "last_scan": None,
        "version": "2.0"
    }
    
    with open("document_registry.json", 'w', encoding='utf-8') as f:
        json.dump(registry, f, ensure_ascii=False, indent=2)
    
    return registry

def check_dependencies():
    """Verifica depend√™ncias necess√°rias"""
    print("\nüîç Verificando depend√™ncias...")
    
    dependencies = {
        "openai": "OpenAI API",
        "tavily": "Tavily (busca web)",
        "llama_index": "LlamaIndex",
        "llama_parse": "LlamaParse (opcional)",
        "python-dotenv": "dotenv"
    }
    
    missing = []
    optional_missing = []
    
    for package, name in dependencies.items():
        try:
            __import__(package.replace("-", "_"))
            print(f"   ‚úÖ {name}")
        except ImportError:
            if "opcional" in name:
                optional_missing.append(f"{package} ({name})")
                print(f"   ‚ö†Ô∏è  {name} - n√£o instalado")
            else:
                missing.append(f"{package} ({name})")
                print(f"   ‚ùå {name} - NECESS√ÅRIO")
    
    if missing:
        print(f"\n‚ùå Depend√™ncias faltando! Instale com:")
        print(f"   pip install {' '.join([m.split()[0] for m in missing])}")
    
    if optional_missing:
        print(f"\nüí° Depend√™ncias opcionais:")
        print(f"   pip install {' '.join([m.split()[0] for m in optional_missing])}")
    
    return len(missing) == 0

def create_sample_queries():
    """Cria arquivo com queries de exemplo"""
    sample_queries = {
        "queries": [
            {
                "tipo": "empresa_especifica",
                "query": "Qual foi o resultado da Petrobras no √∫ltimo trimestre?",
                "estrategia_esperada": "local_first"
            },
            {
                "tipo": "dados_tempo_real",
                "query": "Qual a cota√ß√£o atual do d√≥lar?",
                "estrategia_esperada": "web_priority"
            },
            {
                "tipo": "analise_comparativa",
                "query": "Compare os m√∫ltiplos das empresas do setor banc√°rio",
                "estrategia_esperada": "both"
            },
            {
                "tipo": "macroeconomica",
                "query": "Quais as expectativas para a Selic em 2025?",
                "estrategia_esperada": "web_complement"
            },
            {
                "tipo": "educacional",
                "query": "Explique o conceito de valor intr√≠nseco",
                "estrategia_esperada": "local_only"
            }
        ],
        "dicas": [
            "Seja espec√≠fico ao mencionar empresas ou per√≠odos",
            "Use termos do mercado brasileiro quando relevante",
            "Para dados em tempo real, mencione 'atual' ou 'hoje'",
            "Para an√°lises profundas, pe√ßa 'an√°lise detalhada'"
        ]
    }
    
    with open("sample_queries.json", 'w', encoding='utf-8') as f:
        json.dump(sample_queries, f, ensure_ascii=False, indent=2)
    
    print("\nüìù Arquivo sample_queries.json criado com exemplos!")

def run_system_check():
    """Executa verifica√ß√£o completa do sistema"""
    print("\nüè• Verifica√ß√£o de Sa√∫de do Sistema")
    print("=" * 50)
    
    checks = {
        "folders": check_folders(),
        "registry": check_registry(),
        "env_file": check_env_file(),
        "documents": check_documents()
    }
    
    # Resumo
    print("\nüìä Resumo da Verifica√ß√£o:")
    all_good = True
    for check, status in checks.items():
        icon = "‚úÖ" if status else "‚ùå"
        print(f"   {icon} {check}")
        if not status:
            all_good = False
    
    if all_good:
        print("\nüéâ Sistema pronto para uso!")
    else:
        print("\n‚ö†Ô∏è  Alguns problemas encontrados - verifique acima")
    
    return all_good

def check_folders():
    """Verifica se pastas existem"""
    required_folders = [
        "knowledge_base",
        "knowledge_base/novos_docs",
        "knowledge_base/documentos/resumos"
    ]
    
    for folder in required_folders:
        if not Path(folder).exists():
            return False
    return True

def check_registry():
    """Verifica registro"""
    registry_path = Path("document_registry.json")
    if not registry_path.exists():
        return False
    
    try:
        with open(registry_path, 'r', encoding='utf-8') as f:
            registry = json.load(f)
        return "version" in registry
    except:
        return False

def check_env_file():
    """Verifica arquivo .env"""
    if not Path(".env").exists():
        return False
    
    with open(".env", 'r') as f:
        content = f.read()
    
    return "OPENAI_API_KEY" in content and "TAVILY_KEY" in content

def check_documents():
    """Verifica se h√° documentos"""
    novos_docs = list(Path("knowledge_base/novos_docs").glob("*"))
    processados = list(Path("knowledge_base/docs_processados").glob("*")) if Path("knowledge_base/docs_processados").exists() else []
    
    total = len(novos_docs) + len(processados)
    
    if total > 0:
        print(f"\n   üìÑ Documentos encontrados:")
        print(f"      - Novos: {len(novos_docs)}")
        print(f"      - Processados: {len(processados)}")
    
    return True  # N√£o √© erro n√£o ter documentos

def main():
    """Fun√ß√£o principal do setup"""
    print("üöÄ Setup do Sistema Multi-Agente")
    print("=" * 50)
    
    # Menu
    print("\nO que deseja fazer?")
    print("1. Setup completo (novo sistema)")
    print("2. Migrar sistema existente")
    print("3. Verificar sa√∫de do sistema")
    print("4. Criar arquivos de exemplo")
    print("5. Verificar depend√™ncias")
    
    choice = input("\nEscolha (1-5): ")
    
    if choice == "1":
        print("\nüîß Executando setup completo...")
        setup_folder_structure()
        create_env_template()
        create_new_registry()
        create_sample_queries()
        check_dependencies()
        print("\n‚úÖ Setup completo! Pr√≥ximos passos:")
        print("1. Adicione suas API keys no arquivo .env")
        print("2. Coloque documentos em knowledge_base/novos_docs")
        print("3. Execute o sistema!")
        
    elif choice == "2":
        print("\nüîÑ Migrando sistema existente...")
        setup_folder_structure()
        migrate_old_registry()
        print("\n‚úÖ Migra√ß√£o completa!")
        
    elif choice == "3":
        run_system_check()
        
    elif choice == "4":
        create_sample_queries()
        print("‚úÖ Arquivos de exemplo criados!")
        
    elif choice == "5":
        if check_dependencies():
            print("\n‚úÖ Todas as depend√™ncias necess√°rias instaladas!")
    
    else:
        print("‚ùå Op√ß√£o inv√°lida!")

if __name__ == "__main__":
    main()